import { createClient } from '@/lib/supabase/server';
import { NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { prisma } from '@/lib/db';
import { isAdminEmail } from '@/lib/admin-auth';

export async function GET(request: Request) {
    try {
        const { searchParams, origin } = new URL(request.url);
        const code = searchParams.get('code');
        const next = searchParams.get('next') ?? '/sample-v2/dashboard-v2';

        console.log('[Auth Callback] Triggered:', { hasCode: !!code, next, origin: origin.slice(0, 50) });

        // Check if this is an admin login flow
        const isAdminFlow = next === '/admin' || next.startsWith('/admin');

        if (!code) {
            console.error('[Auth Callback] No code provided');
            const errorRedirect = isAdminFlow ? '/admin/login' : '/login';
            return NextResponse.redirect(`${origin}${errorRedirect}?error=auth_failed`);
        }

        const supabase = await createClient();
        console.log('[Auth Callback] Supabase client created');

        // Exchange the code for a session
        console.log('[Auth Callback] Code received, exchanging for session...');
        const { data, error } = await supabase.auth.exchangeCodeForSession(code);

        if (error) {
            console.error('[Auth Callback] Code exchange failed:', error.message);
        } else if (data.user) {
            console.log('[Auth Callback] Session exchanged successfully for', data.user.email);
        }

        console.log('[Auth Callback] Exchange result:', {
            hasUser: !!data.user,
            error: error?.message,
            hasSession: !!data.session,
            userEmail: data.user?.email
        });

        if (error || !data.user) {
            console.error('[Auth Callback] Exchange error:', error);
            const errorRedirect = isAdminFlow ? '/admin/login' : '/login';
            return NextResponse.redirect(`${origin}${errorRedirect}?error=auth_failed`);
        }

        console.log('[Auth Callback] User authenticated:', data.user.email);

        // Debug: Check what cookies are set after exchange
        const cookieStore = await cookies();
        const allCookies = cookieStore.getAll();
        const authCookies = allCookies.filter(c => c.name.includes('auth') || c.name.includes('supabase'));
        console.log('[Auth Callback] Cookies after exchange:', authCookies.map(c => ({ name: c.name, valueLen: c.value?.length })));

        // Handle admin login flow
        if (isAdminFlow) {
            if (isAdminEmail(data.user.email)) {
                console.log(`[Auth Callback] Admin login: ${data.user.email}`);
                return NextResponse.redirect(`${origin}/admin`);
            } else {
                await supabase.auth.signOut();
                console.warn(`[Auth Callback] Non-admin login attempt: ${data.user.email}`);
                return NextResponse.redirect(`${origin}/admin/login?error=unauthorized`);
            }
        }

        // Regular user flow
        try {
            // Check if user exists in database
            const existingUser = await prisma.user.findUnique({
                where: { supabaseId: data.user.id }
            });

            if (!existingUser) {
                console.log('[Auth Callback] New user - redirecting to registration');
                return NextResponse.redirect(`${origin}/register`);
            }

            // Check if user needs to complete registration (has auto-generated handle)
            const autoGeneratedPattern = /^@user_[a-f0-9]{8}$/;
            const emailPrefix = data.user.email?.split('@')[0];
            const hasAutoHandle = autoGeneratedPattern.test(existingUser.handle) ||
                existingUser.handle === `@${emailPrefix}`;

            if (hasAutoHandle) {
                console.log('[Auth Callback] User needs to complete registration');
                return NextResponse.redirect(`${origin}/register`);
            }

            console.log('[Auth Callback] Existing user - redirecting to dashboard');

            // Create redirect response and ensure cookies are preserved
            const redirectResponse = NextResponse.redirect(`${origin}${next}`);

            // Copy all cookies to the redirect response to ensure session persists
            const finalCookieStore = await cookies();
            finalCookieStore.getAll().forEach((cookie) => {
                redirectResponse.cookies.set(cookie.name, cookie.value);
            });

            console.log('[Auth Callback] Redirecting with cookies:', finalCookieStore.getAll().map(c => c.name));
            return redirectResponse;
        } catch (dbError: any) {
            console.error('[Auth Callback] Database error:', dbError);
            // If DB fails, still redirect to dashboard - user is authenticated with Supabase
            return NextResponse.redirect(`${origin}${next}`);
        }
    } catch (err: any) {
        console.error('[Auth Callback] Fatal error:', err);
        return NextResponse.redirect(`${process.env.NEXT_PUBLIC_SITE_URL || 'https://trenches-dapp.vercel.app'}/login?error=auth_failed`);
    }
}
