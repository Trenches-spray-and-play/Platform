generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id               String           @id @default(uuid())
  handle           String           @unique
  email            String?          @unique
  supabaseId       String?          @unique
  wallet           String?          @unique
  walletEvm        String?          // EVM compatible wallet (ETH/Base/Arbitrum/HyperEVM)
  walletSol        String?          // Solana wallet
  beliefScore      Int              @default(0)
  balance          Decimal          @default(0) @db.Decimal(18, 2) // USD-normalized balance
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  
  // Referral system
  referralCode           String?          @unique    // Unique 8-char code for sharing
  referredById           String?                     // Who referred this user
  referrer               User?            @relation("Referrals", fields: [referredById], references: [id])
  referrals              User[]           @relation("Referrals")
  referralRewardClaimed  Boolean          @default(false) // Prevents duplicate reward
  telegramHandle         String?                     // Telegram username
  
  // Relations
  deposits         Deposit[]
  depositAddresses DepositAddress[]
  participants     Participant[]
  postSubmissions  PostSubmission[]
  sprayEntries     SprayEntry[]
  transactions     Transaction[]
  userTasks        UserTask[]
  validationsGiven Validation[]     @relation("validator")
  campaignWaitlists CampaignWaitlist[]
  userRaids        UserRaid[]
  contentSubmissions UserContentSubmission[]
  withdrawalAddresses WithdrawalAddress[]
  
  // Migration flag for Address Book
  addressBookMigrated Boolean @default(false)
}

model Trench {
  id           String        @id @default(uuid())
  name         String
  level        TrenchLevel
  entrySize    Int
  usdEntry     Int
  durationHours Int          @default(24)  // Baseline wait time: RAPID=24h (1d), MID=168h (7d), DEEP=720h (30d)
  cadence      String
  reserves     String
  active       Boolean       @default(true)
  createdAt    DateTime      @default(now())
  participants Participant[]
  transactions Transaction[]
  sprayEntries SprayEntry[]
}

// SprayEntry tracks spray payments that are pending task completion
model SprayEntry {
  id          String           @id @default(uuid())
  userId      String
  trenchId    String
  amount      Decimal          @db.Decimal(18, 2)  // USD amount
  status      SprayEntryStatus @default(PENDING_TASKS)
  createdAt   DateTime         @default(now())
  finalizedAt DateTime?
  user        User             @relation(fields: [userId], references: [id])
  trench      Trench           @relation(fields: [trenchId], references: [id])
  userTasks   UserTask[]       // Tasks completed for this spray

  @@index([userId])
  @@index([status])
}

enum SprayEntryStatus {
  PENDING_TASKS
  ACTIVE
  EXPIRED
}

model Participant {
  id               String    @id @default(uuid())
  userId           String
  trenchId         String
  status           String
  joinedAt         DateTime  @default(now())
  boostPoints      Int       @default(0)
  entryAmount      Int       @default(0)
  expectedPayoutAt DateTime?                     // Calculated payout time (joinedAt + duration - BP reduction)
  expiresAt        DateTime?
  maxPayout        Int       @default(0)
  receivedAmount   Int       @default(0)
  payoutTxHash     String?                       // Transaction hash once paid
  trench           Trench    @relation(fields: [trenchId], references: [id])
  user             User      @relation(fields: [userId], references: [id])

  @@unique([userId, trenchId])
  @@index([expectedPayoutAt])                   // Index for efficient payout queries
}

model Transaction {
  id            String    @id @default(uuid())
  userId        String
  trenchId      String
  amount        Int
  type          String
  status        String
  targetAddress String
  txHash        String?
  blockNumber   Int?
  fromAddress   String?
  toAddress     String?
  deadline      DateTime
  verifiedAt    DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  trench        Trench    @relation(fields: [trenchId], references: [id])
  user          User      @relation(fields: [userId], references: [id])
}

// Task type: ONE_TIME = done once, never again. RECURRING = must do per spray
enum TaskType {
  ONE_TIME
  RECURRING
}

model UserTask {
  id           String      @id @default(uuid())
  userId       String
  taskId       String
  sprayEntryId String?     // Links to spray entry for recurring tasks
  completedAt  DateTime    @default(now())
  user         User        @relation(fields: [userId], references: [id])
  task         Task        @relation(fields: [taskId], references: [id])
  sprayEntry   SprayEntry? @relation(fields: [sprayEntryId], references: [id])

  @@unique([userId, taskId, sprayEntryId])
  @@index([sprayEntryId])
}

model Task {
  id          String     @id @default(uuid())
  title       String
  description String?
  reward      Int        @default(0)  // Boost points reward
  link        String?                 // External link (Twitter, Telegram, etc.)
  taskType    TaskType   @default(ONE_TIME)  // ONE_TIME or RECURRING
  isActive    Boolean    @default(true)
  order       Int        @default(0)  // Display order
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  completions UserTask[]
}

model PostSubmission {
  id           String       @id @default(uuid())
  userId       String
  platform     String
  url          String
  contentType  String
  status       String       @default("pending")
  endorsements Int          @default(0)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  user         User         @relation(fields: [userId], references: [id])
  validations  Validation[]

  @@unique([userId, contentType])
}

model Validation {
  id            String         @id @default(uuid())
  postId        String
  validatorId   String
  rating        Int
  proofUrl      String?
  endorsed      Boolean        @default(false)
  boostAwarded  Int            @default(0)
  beliefAwarded Int            @default(0)
  createdAt     DateTime       @default(now())
  post          PostSubmission @relation(fields: [postId], references: [id])
  validator     User           @relation("validator", fields: [validatorId], references: [id])

  @@unique([postId, validatorId])
}

model DepositAddress {
  id              String    @id @default(uuid())
  userId          String
  chain           String
  address         String    @unique
  derivationIndex Int
  createdAt       DateTime  @default(now())
  deposits        Deposit[]
  user            User      @relation(fields: [userId], references: [id])
  
  // Cached on-chain balance for admin display
  cachedBalance      Decimal?  @db.Decimal(36, 18)
  cachedBalanceAt    DateTime?

  @@unique([userId, chain])
  @@index([address])
  @@index([userId])
}

model Deposit {
  id               String         @id @default(uuid())
  depositAddressId String
  userId           String
  txHash           String         @unique
  chain            String
  asset            String
  amount           Decimal        @db.Decimal(36, 18)
  amountUsd        Decimal        @db.Decimal(18, 2)
  status           DepositStatus  @default(PENDING)
  blockNumber      BigInt
  confirmations    Int            @default(0)
  confirmedAt      DateTime?
  sweepBatchId     String?
  sweepTxHash      String?
  sweptAt          DateTime?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  
  // Reorg protection fields
  blockHash           String?              // Block hash where tx was first seen
  confirmingAt        DateTime?            // When CONFIRMING status reached
  safeAt              DateTime?            // When SAFE status reached (credit applied)
  creditedToBalance   Boolean   @default(false)  // Track if credit was applied
  reorgDetectedAt     DateTime?            // When reorg was detected
  
  depositAddress   DepositAddress @relation(fields: [depositAddressId], references: [id])
  sweepBatch       SweepBatch?    @relation(fields: [sweepBatchId], references: [id])
  user             User           @relation(fields: [userId], references: [id])
  reorgIncidents   ReorgIncident[]

  @@index([userId])
  @@index([status])
  @@index([depositAddressId])
}

model VaultAddress {
  id      String @id @default(uuid())
  chain   String @unique
  address String
  purpose String @default("primary")
}

model SweepBatch {
  id           String      @id @default(uuid())
  chain        String
  txHash       String?
  status       SweepStatus @default(PENDING)
  depositCount Int
  totalAmount  Decimal     @db.Decimal(36, 18)
  gasCost      Decimal?    @db.Decimal(36, 18)
  createdAt    DateTime    @default(now())
  executedAt   DateTime?
  deposits     Deposit[]

  @@index([status])
  @@index([chain])
}

enum TrenchLevel {
  RAPID
  MID
  DEEP
}

enum DepositStatus {
  PENDING      // Initial detection, awaiting confirmations
  CONFIRMING   // Has required confirmations, in safety window
  SAFE         // Fully safe, credit applied
  CONFIRMED    // Legacy - kept for backwards compatibility
  REORGED      // Transaction was reorged out, credit reversed
  SWEPT        // Funds moved to vault
  FAILED       // Other failure conditions
}

enum SweepStatus {
  PENDING
  EXECUTING
  COMPLETED
  FAILED
}

// Tracks reorg incidents for deposits that were reversed or need review
model ReorgIncident {
  id          String   @id @default(cuid())
  depositId   String
  userId      String
  amount      Decimal  @db.Decimal(18, 2)
  status      String   // REVERSED, REQUIRES_REVIEW
  reason      String?
  detectedAt  DateTime
  resolvedAt  DateTime?
  resolvedBy  String?  // Admin who resolved
  
  deposit     Deposit  @relation(fields: [depositId], references: [id])
  
  @@index([status])
  @@index([userId])
}

// Tracks reorg detection metrics by chain
model ReorgMetric {
  id        String   @id @default(cuid())
  chain     String
  type      String   // detected, reversed, review, check_failure
  date      DateTime @default(now())
  
  @@index([chain, date])
}

enum PayoutStatus {
  PENDING
  EXECUTING
  CONFIRMED
  FAILED
}

model Payout {
  id            String       @id @default(uuid())
  participantId String
  userId        String
  trenchId      String
  amount        Decimal      @db.Decimal(36, 18)
  amountUsd     Decimal      @db.Decimal(18, 2)
  toAddress     String
  tokenAddress  String
  tokenSymbol   String
  chainId       Int
  txHash        String?
  status        PayoutStatus @default(PENDING)
  createdAt     DateTime     @default(now())
  executedAt    DateTime?
  confirmedAt   DateTime?

  @@index([userId])
  @@index([status])
  @@index([participantId])
}

model CampaignConfig {
  id              String   @id @default(uuid())
  name            String   @default("Default Campaign")  // Campaign name
  trenchIds       String[] @default([])                  // Array of trench IDs this campaign applies to
  // Payout token configuration
  tokenAddress    String
  tokenSymbol     String
  tokenDecimals   Int                             // Configurable decimals
  chainId         Int
  chainName       String                          // Configurable chain name
  // Accepted deposit tokens (JSON array of {address, symbol, chainId})
  acceptedTokens  String   @default("[]")         // JSON: [{address, symbol, chainId}]
  // ROI configuration
  roiMultiplier   Decimal  @default(1.5) @db.Decimal(5, 2)  // 1.5x, 2.0x, etc
  // Price configuration
  manualPrice     Decimal? @db.Decimal(18, 8)
  useOracle       Boolean  @default(false)
  oracleSource    String?
  // Reserve configuration
  reserveRoundingUnit    Int       @default(1000000)  // 1M default
  reserveCachedBalance   String?   // Cached display "500M $BLT"
  reserveCacheUpdatedAt  DateTime?
  // Status
  isHidden        Boolean  @default(false)       // Hide from homepage
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Campaign timing & waitlist
  startsAt                   DateTime?            // When campaign goes live (null = already live)
  acceptDepositsBeforeStart  Boolean  @default(false)  // Accept deposits during wait period
  isPaused                   Boolean  @default(false)  // Pause payouts
  payoutIntervalSeconds      Int      @default(5)      // Seconds between payouts
  
  // Relations
  waitlist        CampaignWaitlist[]
}

// Waitlist for campaigns that haven't started yet
model CampaignWaitlist {
  id            String   @id @default(uuid())
  campaignId    String
  userId        String
  hasDeposited  Boolean  @default(false)
  depositAmount Decimal? @db.Decimal(18, 2)
  joinedAt      DateTime @default(now())
  queueNumber   Int?                           // Assigned based on joinedAt order
  
  campaign      CampaignConfig @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  user          User           @relation(fields: [userId], references: [id])
  
  @@unique([campaignId, userId])
  @@index([campaignId, hasDeposited])
}

// Tracks all config changes for audit trail and rollback
model ConfigAuditLog {
  id         String   @id @default(cuid())
  configType String   // 'campaign' | 'platform'
  configId   String   // ID of the config being changed
  field      String   // Which field changed
  oldValue   String?  // Previous value (JSON string)
  newValue   String?  // New value (JSON string)
  changedBy  String   // Admin who made the change
  changedAt  DateTime @default(now())
  
  @@index([configId, changedAt])
  @@index([configType, changedAt])
}

// Centralized Platform Configuration (singleton pattern)
model PlatformConfig {
  id                      String   @id @default("default")
  
  // Deployment Timer (Universal Countdown)
  deploymentDate          DateTime?
  
  // Social Media Links
  telegramUrl             String   @default("https://t.me/trenchesprotocol")
  twitterUrl              String   @default("https://x.com/traboraofficial")
  twitterHandle           String   @default("@traboraofficial")
  onboardingTweetText     String   @default("Just enlisted in the @traboraofficial deployment queue. Spray and Pray! ðŸ”«")
  
  // Branding
  platformName            String   @default("Trenches")
  referralDomain          String   @default("playtrenches.xyz")
  docsUrl                 String   @default("https://docs.playtrenches.xyz")
  
  // Status Messages
  waitlistStatusMessage   String   @default("WAITLIST PROTOCOL ACTIVE")
  deploymentStatusMessage String   @default("DEPLOYMENT WINDOW OPEN")
  
  // Belief Score Tier Configuration (JSON array)
  // Format: [{"minScore": 0, "multiplier": 0.5}, {"minScore": 100, "multiplier": 0.75}, ...]
  beliefTiers             String   @default("[{\"minScore\":0,\"multiplier\":0.5},{\"minScore\":100,\"multiplier\":0.75},{\"minScore\":500,\"multiplier\":0.9},{\"minScore\":1000,\"multiplier\":1.0}]")
  
  // Time-Based Payout Configuration
  bpToMinutesRate         Int      @default(1)   // 1 BP = X minutes off payout time
  
  // Metadata
  updatedAt               DateTime @updatedAt
  updatedBy               String?
}

// ========================================
// EARN HUB MODELS (Content Market & Raids)
// ========================================

// Content Campaign - brands paying for content syndication (rewards Belief Points)
model ContentCampaign {
  id                    String   @id @default(uuid())
  brand                 String                           // Brand name (e.g., "MetaWin")
  name                  String                           // Campaign name (e.g., "Elite Clipping")
  description           String?
  platforms             String[] @default([])            // ["X", "TT", "IG"]
  beliefPointsPer1k     Decimal  @db.Decimal(5, 2)       // Belief Points per 1k views (e.g., 1.5)
  usdPer1k              Decimal? @db.Decimal(10, 2)      // Optional USD reward per 1k views
  budgetUsd             Decimal? @db.Decimal(18, 2)      // Total campaign budget
  spentUsd              Decimal  @default(0) @db.Decimal(18, 2) // Amount spent so far
  icon                  String?                          // Emoji or icon URL
  isActive              Boolean  @default(true)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relations
  submissions           UserContentSubmission[]
}

// User's content submission to a campaign
model UserContentSubmission {
  id                String          @id @default(uuid())
  userId            String
  campaignId        String
  url               String                               // The social link submitted
  platform          String                               // X, TT, IG, YT
  viewCount         Int             @default(0)          // Verified view count
  beliefAwarded     Decimal         @default(0) @db.Decimal(5, 2) // BP awarded (60 on approval)
  usdAwarded        Decimal?        @db.Decimal(10, 2)   // USD awarded (optional)
  status            String          @default("pending")  // pending, approved, rejected
  createdAt         DateTime        @default(now())
  verifiedAt        DateTime?

  user              User            @relation(fields: [userId], references: [id])
  campaign          ContentCampaign @relation(fields: [campaignId], references: [id])
  raid              Raid?                                // Auto-created raid on approval

  @@index([userId])
  @@index([campaignId])
  @@index([status])
}

// Raid Campaign - social amplification targets (rewards Boost Points)
model Raid {
  id                    String                  @id @default(uuid())
  title                 String
  platform              String                                     // X, TT, IG, YT
  url                   String                                     // The social link to raid
  reward                Int                     @default(5)        // BP reward (default 5)
  isActive              Boolean                 @default(true)
  createdAt             DateTime                @default(now())
  expiresAt             DateTime?
  contentSubmissionId   String?                 @unique            // Link to auto-created raid's source
  contentSubmission     UserContentSubmission?  @relation(fields: [contentSubmissionId], references: [id])

  // Relations
  completions UserRaid[]
}

// Tracks which users have completed which raids
model UserRaid {
  id          String   @id @default(uuid())
  userId      String
  raidId      String
  bpAwarded   Int      @default(0)
  completedAt DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id])
  raid        Raid     @relation(fields: [raidId], references: [id])

  @@unique([userId, raidId])
  @@index([userId])
  @@index([raidId])
}

// ============== Address Book System ==============

enum AddressStatus {
  PENDING   // Awaiting email confirm OR 24h delay
  ACTIVE    // Ready to receive payouts
}

enum AddressChain {
  EVM       // Ethereum/Base/Arbitrum/HyperEVM
  SOLANA
}

model WithdrawalAddress {
  id                String        @id @default(cuid())
  userId            String
  user              User          @relation(fields: [userId], references: [id])
  
  address           String
  chain             AddressChain
  label             String?       // User-defined name (e.g., "Ledger")
  status            AddressStatus @default(PENDING)
  isPrimary         Boolean       @default(false) // One per chain
  
  // Email confirmation
  emailConfirmed    Boolean       @default(false)
  confirmationToken String?       @unique
  tokenExpiresAt    DateTime?     // 7 days from creation
  
  // 24h activation delay
  activatesAt       DateTime?     // Set on email confirm (+24h)
  activatedAt       DateTime?
  
  createdAt         DateTime      @default(now())
  
  @@unique([userId, address, chain])
  @@index([userId, chain, isPrimary])
  @@index([confirmationToken])
  @@index([status, emailConfirmed, activatesAt])
}
